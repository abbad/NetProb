'''
Created on may 7, 2013

@author: Abbad

This module will call UDP server and TCP server.

'''

from subprocess import Popen
from time import sleep
from os import system, remove, listdir, pipe, fdopen, close, O_RDONLY, O_WRONLY
from os import path as osPath
from inspect import currentframe, getfile
from sys import path

# code to include subfolder modules (packages)
cmd_subfolder = osPath.realpath(osPath.abspath(osPath.join(osPath.split(getfile( currentframe() ))[0],"subfolder")))
if cmd_subfolder not in path:
	path.insert(0, cmd_subfolder)

from utilities.getChar import *
from utilities.user_pipes import getHandleDuplicate, closePipe

def cleanUp():
	'''
		delete all xml files that are generated by udp server.
	'''
	for files in listdir("."):
			if files.endswith(".xml"):
				remove(files)
				
def menu():
	
	p1 = None
	p2 = None
	
	while 1:
		print "Select one of the following:"
		print "1. start TCP Client"
		print "2. start UDP Server"
		print "3. quit"
		getch = Getch() 
		val = getch.__call__()
		if val == '1':
			p1 = launchTCPClient()
		if val == '2':
			p2 = launchUdpServer()
		if val == '3':
			try:
				if p1:
					p1.terminate()
				if p2:
					p2.terminate()
			except:
				print "error while terminating one of the processes"
			exit()
			
'''
	@pipeArg1 This is for sending command and also notification period to receiver. 
	@pipeArg2 This is for statistics. 
'''
def launchTcpClient(pipeArg1):
	print 'Starting TCP client'
	args = ["python", "TCPClient.py", "-a", pipeArg1]
	return Popen(args, shell=False, close_fds = False)

'''
	@pipeArg1 This is for sending statistics. 
'''
def launchUdpServer(notificationPeriod):
	print 'Starting UDP server'
	args =  ["python", "UDPserver.py", "-n", notificationPeriod]
	p2 = Popen(args, shell=False, close_fds = False)

'''
	create a pipe between parent and tcp client. 
'''
def CreatePipeBetweenParentAndTcpClient():
	pipeout, pipein = pipe()
	
	pipeInDuplicate = getHandleDuplicate(pipein)
	
	return pipeout, pipein, pipeInDuplicate

'''
	get message from tcp client, which it got from the sender part of the program.
'''
def getMessageFromTcpClient(pipeout):
	pipefh = fdopen(pipeout, 'r')
	message = pipefh.read()
	pipefh.close()
	return message
	
if __name__ == '__main__':
	cleanUp()
	# Must close pipe input if child will block waiting for end
	# Can also be closed in a preexec_fn passed to subprocess.Popen
	#fcntl(pipeToClose, fcntl.F_SETFD, fcntl.FD_CLOEXEC)
	 
	# Create pipe for handshake
	handShake = CreatePipeBetweenParentAndTcpClient()
	
	# Start child with argument indicating which FD/FH to read from
	TCPsubproc = launchTcpClient(str(int(handShake[2])))

	# Close write end of the pipe in parent
	closePipe(handShake[1], handShake[2])
	
	# wait for message from tcp client
	message = getMessageFromTcpClient(handShake[0])
	
	if(message[0:14] == "startUdpServer"):
		UDPServerSubProc = launchUdpServer(message[14:])
		